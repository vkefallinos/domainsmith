#!/usr/bin/env node
/**
 * generate-oneshot.cjs
 *
 * Starts from product-plan/prompts/one-shot-prompt.md, recursively follows
 * all referenced files and directories, and concatenates file names + contents
 * into product-plan/oneshotfullprompt.md.
 */

const fs = require('fs');
const path = require('path');

const REPO_ROOT = path.resolve(__dirname, '..');
const PRODUCT_PLAN_DIR = __dirname;
const STARTING_FILE = path.join(PRODUCT_PLAN_DIR, 'prompts', 'one-shot-prompt.md');
const OUTPUT_FILE = path.join(PRODUCT_PLAN_DIR, 'oneshotfullprompt.md');

/**
 * Resolve a reference path (from a file's content) to an absolute filesystem path.
 * Handles:
 *   - @product-plan/... → <repo-root>/product-plan/...
 *   - product-plan/...  → <repo-root>/product-plan/...
 *   - relative paths    → resolved relative to the containing file
 */
function resolveRef(ref, containingFile) {
  // Strip leading @ if present
  const cleaned = ref.startsWith('@') ? ref.slice(1) : ref;

  if (cleaned.startsWith('product-plan/')) {
    return path.join(REPO_ROOT, cleaned);
  }

  // Relative path — resolve from the directory of the containing file
  return path.resolve(path.dirname(containingFile), cleaned);
}

/**
 * Extract all file/directory references from a file's text content.
 * Looks for:
 *   - @product-plan/...   (Design OS notation)
 *   - `product-plan/...`  (backtick code spans)
 *   - Markdown links: [text](path)
 *   - Plain `product-plan/...` occurrences
 */
function extractRefs(content) {
  const refs = new Set();

  // @product-plan/path references
  // Excludes whitespace and markdown/code punctuation: * ` ) ] ' "
  const pathChars = '[^\\s*`)"\\]\']+';
  const atRe = new RegExp(`@(product-plan\\/${pathChars})`, 'g');
  let m;
  while ((m = atRe.exec(content)) !== null) {
    refs.add(m[1]);
  }

  // Plain product-plan/path references (possibly in backticks or plain text)
  const plainRe = new RegExp(`\\b(product-plan\\/${pathChars})`, 'g');
  while ((m = plainRe.exec(content)) !== null) {
    refs.add(m[1]);
  }

  // Markdown links [text](./relative/path) — only include paths that look like files
  const linkRe = /\[.*?\]\(([^)]+)\)/g;
  while ((m = linkRe.exec(content)) !== null) {
    const href = m[1].trim();
    // Skip http(s) URLs and anchor-only links
    if (!href.startsWith('http') && !href.startsWith('#')) {
      refs.add(href);
    }
  }

  return Array.from(refs);
}

/**
 * Collect all files under a directory recursively, sorted for determinism.
 */
function collectDirFiles(dirPath) {
  const results = [];
  if (!fs.existsSync(dirPath)) return results;
  const entries = fs.readdirSync(dirPath, { withFileTypes: true }).sort((a, b) =>
    a.name.localeCompare(b.name)
  );
  for (const entry of entries) {
    const full = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      results.push(...collectDirFiles(full));
    } else {
      results.push(full);
    }
  }
  return results;
}

/**
 * Recursively walk references starting from `filePath`.
 * Returns an ordered array of unique absolute file paths.
 */
function collectFiles(filePath, visited = new Set(), order = []) {
  if (visited.has(filePath)) return order;
  if (!fs.existsSync(filePath)) return order;

  const stat = fs.statSync(filePath);

  if (stat.isDirectory()) {
    // Expand directory to all contained files
    const files = collectDirFiles(filePath);
    for (const f of files) {
      collectFiles(f, visited, order);
    }
    return order;
  }

  // It's a regular file
  visited.add(filePath);
  order.push(filePath);

  // Parse content for further references
  let content;
  try {
    content = fs.readFileSync(filePath, 'utf8');
  } catch (err) {
    console.warn(`Warning: could not read ${displayName(filePath)}: ${err.message}`);
    return order;
  }

  const refs = extractRefs(content);
  for (const ref of refs) {
    const resolved = resolveRef(ref, filePath);
    collectFiles(resolved, visited, order);
  }

  return order;
}

/**
 * Return a display name for a file relative to the repo root.
 */
function displayName(absPath) {
  return path.relative(REPO_ROOT, absPath);
}

/**
 * Build the concatenated output.
 */
function buildOutput(files) {
  const parts = [];

  parts.push('# One-Shot Full Prompt\n');
  parts.push(
    `_This file is auto-generated by \`product-plan/generate-oneshot.cjs\`._\n` +
    `_It concatenates all files reachable from \`product-plan/prompts/one-shot-prompt.md\`._\n`
  );
  parts.push('---\n');

  for (const filePath of files) {
    const name = displayName(filePath);
    let content;
    try {
      content = fs.readFileSync(filePath, 'utf8');
    } catch {
      content = '_(could not read file)_';
    }

    parts.push(`\n## ${name}\n`);
    parts.push('```\n' + content + '\n```\n');
  }

  return parts.join('\n');
}

// ── Main ────────────────────────────────────────────────────────────────────

const files = collectFiles(STARTING_FILE);

// Exclude the output file itself if somehow it ends up in the list
const filtered = files.filter(f => f !== OUTPUT_FILE);

const output = buildOutput(filtered);

fs.writeFileSync(OUTPUT_FILE, output, 'utf8');

console.log(`✓ Written ${filtered.length} files to ${path.relative(REPO_ROOT, OUTPUT_FILE)}`);
filtered.forEach(f => console.log('  •', displayName(f)));
